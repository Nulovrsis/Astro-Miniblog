/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// main.ts
var main_exports = {};
__export(main_exports, {
  default: () => YearlyDiaryComparatorPlugin
});
module.exports = __toCommonJS(main_exports);
var import_obsidian = require("obsidian");
var DEFAULT_SETTINGS = {
  summaryHeading: "[DAILY_SUMMARY]",
  yearColWidth: 480
};
var YearlyDiaryComparatorSettingTab = class extends import_obsidian.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    new import_obsidian.Setting(containerEl).setName("Extract keyword").setDesc(
      "Heading keyword to extract data from\uFF08eg, [DAILY_SUMMARY]\uFF09"
    ).addText(
      (text) => text.setPlaceholder("[DAILY_SUMMARY]").setValue(this.plugin.settings.summaryHeading).onChange(async (value) => {
        this.plugin.settings.summaryHeading = value || "[DAILY_SUMMARY]";
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian.Setting(containerEl).setName("Width of year columns").setDesc("Width of year columns (eg. 480)").addText(
      (text) => text.setPlaceholder("480").setValue(String(this.plugin.settings.yearColWidth)).onChange(async (value) => {
        const num = Number(value);
        this.plugin.settings.yearColWidth = !isNaN(num) && num > 0 ? num : 480;
        await this.plugin.saveSettings();
      })
    );
  }
};
var VIEW_TYPE_YEARLY_DIARY_COMPARE = "yearly-diary-compare-view";
var YearlyDiaryComparatorPlugin = class extends import_obsidian.Plugin {
  async onload() {
    await this.loadSettings();
    this.addSettingTab(new YearlyDiaryComparatorSettingTab(this.app, this));
    this.addRibbonIcon("columns-3", "Open yearly comparator", () => {
      const leaves = this.app.workspace.getLeavesOfType(
        VIEW_TYPE_YEARLY_DIARY_COMPARE
      );
      if (leaves.length > 0) {
        this.app.workspace.revealLeaf(leaves[0]);
      } else {
        this.activateView();
      }
    });
    this.registerView(
      VIEW_TYPE_YEARLY_DIARY_COMPARE,
      (leaf) => new YearlyDiaryCompareView(leaf, this)
    );
  }
  async activateView() {
    const { workspace } = this.app;
    let leaf = null;
    const existingLeaf = workspace.getLeavesOfType(
      VIEW_TYPE_YEARLY_DIARY_COMPARE
    )[0];
    if (existingLeaf) {
      leaf = existingLeaf;
    } else {
      leaf = workspace.getRightLeaf(false);
      if (leaf) {
        await leaf.setViewState({
          type: VIEW_TYPE_YEARLY_DIARY_COMPARE,
          active: true
        });
      }
    }
    if (leaf) {
      workspace.revealLeaf(leaf);
    }
  }
  onunload() {
  }
  async loadSettings() {
    this.settings = Object.assign(
      {},
      DEFAULT_SETTINGS,
      await this.loadData()
    );
  }
  async saveSettings() {
    await this.saveData(this.settings);
  }
  /**
   * function to get diary data
   */
  async getYearDiaryMap() {
    var _a, _b, _c, _d;
    let dailyNoteFolder = void 0;
    const internalDailyNotes = (_b = (_a = this.app.internalPlugins) == null ? void 0 : _a.plugins) == null ? void 0 : _b["daily-notes"];
    if (internalDailyNotes && ((_d = (_c = internalDailyNotes == null ? void 0 : internalDailyNotes.instance) == null ? void 0 : _c.options) == null ? void 0 : _d.folder) !== void 0) {
      dailyNoteFolder = internalDailyNotes.instance.options.folder;
    }
    const files = this.app.vault.getFiles();
    let dailyNoteFiles;
    if (!dailyNoteFolder) {
      dailyNoteFiles = files.filter(
        (file) => !file.path.includes("/")
      );
    } else {
      dailyNoteFiles = files.filter(
        (file) => file.path.startsWith(dailyNoteFolder + "/")
      );
    }
    const yearSet = /* @__PURE__ */ new Set();
    const yearRegex = /^(\d{4})-\d{2}-\d{2}$/;
    const pathYearRegex = /(\d{4})-\d{2}-\d{2}\.md$/;
    for (const file of dailyNoteFiles) {
      const baseMatch = file.basename.match(yearRegex);
      const pathMatch = file.path.match(pathYearRegex);
      if (baseMatch) {
        yearSet.add(baseMatch[1]);
      } else if (pathMatch) {
        yearSet.add(pathMatch[1]);
      }
    }
    const yearDiaryMap = {};
    for (const year of yearSet) {
      const dateMap = {};
      const startDate = new Date(Number(year), 0, 1);
      const endDate = new Date(Number(year), 11, 31);
      for (let d = new Date(startDate); d <= endDate; d.setDate(d.getDate() + 1)) {
        const mm = String(d.getMonth() + 1).padStart(2, "0");
        const dd = String(d.getDate()).padStart(2, "0");
        const dateStr = `${year}-${mm}-${dd}`;
        const file = dailyNoteFiles.find(
          (f) => f.basename === dateStr
        );
        dateMap[dateStr] = file ? file.path : void 0;
      }
      yearDiaryMap[year] = dateMap;
    }
    return yearDiaryMap;
  }
};
var YearlyDiaryCompareView = class extends import_obsidian.ItemView {
  constructor(leaf, plugin) {
    super(leaf);
    // keep function to cleanup
    this._renderTableHandler = null;
    this.showDailyNote = (app, filePath) => {
      const file = app.vault.getFileByPath(filePath);
      if (file) {
        const centerLeaf = this.plugin.app.workspace.getLeaf(false);
        if (centerLeaf) {
          centerLeaf.openFile(file, {
            active: true
          });
          app.workspace.revealLeaf(centerLeaf);
        }
      }
    };
    this.plugin = plugin;
  }
  getViewType() {
    return VIEW_TYPE_YEARLY_DIARY_COMPARE;
  }
  getDisplayText() {
    return "Yearly diary comparator";
  }
  async onOpen() {
    const container = this.containerEl.children[1];
    container.empty();
    const titleWrapper = container.createEl("div", {
      cls: "ydc-title-wrapper"
    });
    new import_obsidian.Setting(titleWrapper).setName("Yearly diary comparator").setHeading();
    const reloadBtn = titleWrapper.createEl("button", {
      cls: "ydc-reload-btn"
    });
    reloadBtn.title = "Reload table";
    const iconSpan = reloadBtn.createSpan();
    iconSpan.textContent = "\u27F3";
    iconSpan.title = "reload table";
    iconSpan.className = "reload-icon";
    reloadBtn.appendChild(iconSpan);
    const yearDiaryMap = await this.plugin.getYearDiaryMap();
    const yearList = Object.keys(yearDiaryMap).sort();
    const tableWrapper = container.createEl("div", {
      cls: "ydc-table-wrapper"
    });
    const yearColCount = yearList.length;
    const dayColWidth = 56;
    const yearColWidth = this.plugin.settings.yearColWidth;
    const minTableWidth = dayColWidth + yearColWidth * yearColCount;
    const table = tableWrapper.createEl("table", {
      cls: "ydc-diary-table"
    });
    table.style.minWidth = `${minTableWidth}px`;
    const thead = table.createEl("thead");
    const tbody = table.createEl("tbody");
    const days = [];
    for (let month = 0; month < 12; month++) {
      for (let day = 1; day <= 31; day++) {
        const mm = String(month + 1).padStart(2, "0");
        const dd = String(day).padStart(2, "0");
        if ((/* @__PURE__ */ new Date(`2020-${mm}-${dd}`)).getMonth() + 1 !== month + 1)
          continue;
        days.push(`${mm}-${dd}`);
      }
    }
    const plugin = this.plugin;
    const renderTable = () => {
      thead.empty();
      const headerRow = thead.createEl("tr");
      headerRow.createEl("th", {
        text: "day",
        cls: "th-day"
      });
      for (const year of yearList) {
        headerRow.createEl("th", {
          text: year,
          cls: "th-year"
        });
      }
      tbody.empty();
      const days2 = [];
      for (let month = 0; month < 12; month++) {
        for (let day = 1; day <= 31; day++) {
          const mm = String(month + 1).padStart(2, "0");
          const dd = String(day).padStart(2, "0");
          if ((/* @__PURE__ */ new Date(`2020-${mm}-${dd}`)).getMonth() + 1 !== month + 1)
            continue;
          days2.push(`${mm}-${dd}`);
        }
      }
      const today = /* @__PURE__ */ new Date();
      const todayStr = `${String(today.getMonth() + 1).padStart(
        2,
        "0"
      )}-${String(today.getDate()).padStart(2, "0")}`;
      for (const mmdd of days2) {
        const tdDayCls = mmdd === todayStr ? "td-day today-highlight" : "td-day";
        const row = tbody.createEl("tr");
        row.createEl("td", { text: mmdd, cls: tdDayCls });
        for (const year of yearList) {
          const dateStr = `${year}-${mmdd}`;
          const filePath = yearDiaryMap[year][dateStr];
          const cell = row.createEl("td", {
            text: "",
            cls: "td-year"
          });
          if (filePath) {
            cell.addClass("clickable-diary-cell");
            cell.setText("loading...");
            cell.setAttr("title", "open note");
            const file = this.plugin.app.vault.getFileByPath(filePath);
            if (file) {
              (async () => {
                try {
                  const content = await this.plugin.app.vault.read(file);
                  const lines = content.split("\n");
                  const headingPattern = this.plugin.settings.summaryHeading.trim();
                  const headingRegex = new RegExp(
                    "^#+\\s*" + headingPattern.replace(
                      /[-\/\\^$*+?.()|[\]{}]/g,
                      "\\$&"
                    )
                  );
                  const summaryLineNum = lines.findIndex(
                    (line) => headingRegex.test(line)
                  );
                  cell.empty();
                  const iconSpan2 = cell.createSpan();
                  iconSpan2.textContent = "\u{1F4C4}";
                  iconSpan2.title = "open note";
                  iconSpan2.className = "open-note-icon";
                  iconSpan2.addEventListener(
                    "click",
                    async (e) => {
                      e.stopPropagation();
                      await this.showDailyNote(
                        plugin.app,
                        filePath
                      );
                    }
                  );
                  cell.appendChild(iconSpan2);
                  if (summaryLineNum !== -1) {
                    const summaryLevel = (lines[summaryLineNum].match(/^#+/) || ["#"])[0].length;
                    let endLineNum = lines.length;
                    for (let i = summaryLineNum + 1; i < lines.length; i++) {
                      const m = lines[i].match(/^(#+)\s+/);
                      if (m && m[1].length <= summaryLevel) {
                        endLineNum = i;
                        break;
                      }
                    }
                    const summary = lines.slice(
                      summaryLineNum + 1,
                      endLineNum
                    ).join("\n").trim();
                    if (summary) {
                      import_obsidian.MarkdownRenderer.render(
                        this.app,
                        summary,
                        cell,
                        "",
                        plugin
                      );
                    } else {
                      const noneSpan = cell.createSpan();
                      cell.appendChild(noneSpan);
                    }
                  }
                } catch (err) {
                  console.error(
                    "Markdown render error:",
                    err
                  );
                  cell.setText("(read error)");
                }
              })();
            } else {
              cell.setText("(no file found)");
            }
            this.registerDomEvent(cell, "click", async () => {
              await this.showDailyNote(plugin.app, filePath);
            });
          } else {
            cell.setText("");
            cell.setAttr("title", "no note");
          }
        }
      }
    };
    this.registerDomEvent(reloadBtn, "click", () => {
      renderTable();
    });
    renderTable();
    window.setTimeout(() => {
      var _a, _b;
      tableWrapper.scrollLeft = tableWrapper.scrollWidth;
      const today = /* @__PURE__ */ new Date();
      const mm = String(today.getMonth() + 1).padStart(2, "0");
      const dd = String(today.getDate()).padStart(2, "0");
      const todayStr = `${mm}-${dd}`;
      const rowIndex = days.indexOf(todayStr);
      if (rowIndex !== -1) {
        const trList = tbody.querySelectorAll("tr");
        const visibleHeight = tableWrapper.clientHeight;
        let top = 0;
        for (let i = 0; i < rowIndex; i++) {
          top += trList[i].offsetHeight;
        }
        const rowHeight = (_b = (_a = trList[rowIndex]) == null ? void 0 : _a.offsetHeight) != null ? _b : 24;
        const totalHeight = Array.from(trList).reduce(
          (sum, tr) => {
            var _a2;
            return sum + ((_a2 = tr.offsetHeight) != null ? _a2 : 24);
          },
          0
        );
        let scrollTop = top - visibleHeight / 2 + rowHeight / 2;
        scrollTop = Math.max(
          0,
          Math.min(scrollTop, totalHeight - visibleHeight)
        );
        tableWrapper.scrollTop = scrollTop;
      }
    }, 0);
    this.registerDomEvent(window, "resize", renderTable);
    this._renderTableHandler = renderTable;
  }
  async onClose() {
    if (this._renderTableHandler) {
      this._renderTableHandler = null;
    }
    const container = this.containerEl.children[1];
    if (container) {
      container.empty();
    }
  }
};


/* nosourcemap */